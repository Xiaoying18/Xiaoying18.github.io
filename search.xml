<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode 797. 所有可能的路径</title>
    <url>/2020/08/05/Leetcode%20797.%20%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="Leetcode-797-所有可能的路径"><a href="#Leetcode-797-所有可能的路径" class="headerlink" title="Leetcode 797. 所有可能的路径"></a>Leetcode 797. 所有可能的路径</h1><h2 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h2><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给一个有 n 个结点的有向无环图，找到所有从 0 到 n-1 的路径并输出（不要求按顺序）</p>
<p>二维数组的第 i 个数组中的单元都表示有向图中 i 号结点所能到达的下一些结点（译者注：有向图是有方向的，即规定了a→b你就不能从b→a）空就是没有下一个结点了。</p>
<p><strong>示例:</strong><br>输入: [[1,2], [3], [3], []]<br>输出: [[0,1,3],[0,2,3]] </p>
<p><em>解释:</em> 图是这样的:<br>0—&gt;1<br>|    |<br>v    v<br>2—&gt;3<br>这有两条路: <code>0 -&gt; 1 -&gt; 3</code> 和 <code>0 -&gt; 2 -&gt; 3</code>.</p>
<p><strong>提示:</strong></p>
<ul>
<li>结点的数量会在范围 <code>[2, 15]</code> 内。</li>
<li>你可以把路径以任意顺序输出，但在路径内的结点的顺序必须保证。</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="题目的意思"><a href="#题目的意思" class="headerlink" title="题目的意思"></a>题目的意思</h3><p>这个题大概一看就能知道它要干啥，但是吧，我就是因为这么<strong>大概一看</strong>，这个人都陷入了一顺儿水儿的令人·卧槽· 的bug中去了…</p>
<p>这个图：</p>
<ol>
<li><p>起点必须是 0</p>
</li>
<li><p>终点必须是graph数组的最后一个元素， 注意！</p>
<p>​    例如说：<code>input:[[2],[],[1]]</code>，最后组成的图，要走的路径是 <code>0 -&gt; 1</code> 而不是<code>0 -&gt; 中间那个null</code></p>
</li>
<li><p>再有就是，记录的是路径，也就是说，带开头的 0 ，不带终点的元素。</p>
<p>​    还是上面那个例子：<code>input:[[2],[],[1]]</code>，最后的结果是 <code>[0,2]</code>而不是<code>[0,2,1]</code>，不带那个1，也不用考虑1所在的那个数组格子里面有没有成堆的元素需要遍历。</p>
</li>
</ol>
<p>我为什么知道这么多呢，大概是因为命运和不好好看题的懒惰🙂</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>打眼一看就是个DFS深度搜索。</p>
<h3 id="code-（java）"><a href="#code-（java）" class="headerlink" title="code （java）"></a>code （java）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//check input</span></span><br><span class="line">        <span class="keyword">if</span>(graph == <span class="keyword">null</span> || graph.length == <span class="number">0</span> || graph[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        temp.add(<span class="number">0</span>);    <span class="comment">//注意1:路径的开头总是 0</span></span><br><span class="line">        dfs(graph, <span class="number">0</span>, temp, result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> curr, List&lt;Integer&gt; temp, List&lt;List&lt;Integer&gt;&gt; result)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注意3：确认好corner case下input 与 output， 他这里吧，如果goal位置有元素，是不需要记录goal在路径中的。</span></span><br><span class="line">        <span class="keyword">if</span>(curr == graph.length - <span class="number">1</span> &amp;&amp; !temp.isEmpty())&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//注意2:必须new ArrayList&lt;&gt;(); 不然之后temp list改变，result中的值会跟着改变，（java特性）</span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));      </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[curr].length; i++)&#123;</span><br><span class="line">            temp.add(graph[curr][i]);		<span class="comment">//填一个进去路径中</span></span><br><span class="line">            dfs(graph, graph[curr][i], temp, result);	<span class="comment">//在此路径基础上，dfs</span></span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);		<span class="comment">//回退一位路径。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>走一个test：</p>
<p>输入: [[1,2], [3], [3], []]<br>输出: [[0,1,3],[0,2,3]] </p>
<p>图是这样的:<br>0—&gt;1<br>|    |<br>v    v<br>2—&gt;3<br>结果应该是有两条路: <code>0 -&gt; 1 -&gt; 3</code> 和 <code>0 -&gt; 2 -&gt; 3</code>.</p>
<p><code>[[1,2], [3], [3], []]</code> </p>
<p>temp记录到这一步为止，走过的路径。每次走到头，就将temp路径计入result，然后回退。所以这玩意儿又叫backtrack方法。</p>
<p>temp list：0        //上面说过了，路径开头肯定是 0 </p>
<p>走第0个数组[1, 2]:</p>
<p>​        先试着走1 ：</p>
<p>​                temp : 0, 1</p>
<p>​                进到数组 [3]</p>
<p>​                        temp : 0, 1, 3</p>
<p>​                        进到goal终点数组 [ ]</p>
<p>​                        结束，将形成的temp路线放入result中 ——————-  0 -&gt; 1 -&gt; 3</p>
<p>​                退回数组[3]</p>
<p>​                        temp : 0, 1</p>
<p>​                        没有其他路径了</p>
<p>​    退回数组[1, 2] :</p>
<p>​            temp : 0</p>
<p>​            试着走2：</p>
<p>​                        temp : 0, 2</p>
<p>​                        进到数组 [ 3 ]</p>
<p>​                                temp : [0, 2, 3]</p>
<p>​                                进到goal终点数组 [ ]</p>
<p>​                        结束，将形成的temp路线放入result中———————-0 -&gt; 2 -&gt; 3</p>
<p>​                退回数组[3]</p>
<p>​                        temp : 0, 2</p>
<p>​                        没有其他路径了</p>
<p>​    退回数组[1, 2] :</p>
<p>​            temp : 0</p>
<p>​            没有其他路径了</p>
<p>结束。</p>
<p>​            </p>
<blockquote>
<p>这个题的代码，基本就是DFS深度搜索的框架了，可以参考着记一下。        </p>
</blockquote>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>进程和线程</title>
    <url>/2020/07/24/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="一、对进程的理解"><a href="#一、对进程的理解" class="headerlink" title="一、对进程的理解"></a>一、对进程的理解</h2><h3 id="（一）从哪里来："><a href="#（一）从哪里来：" class="headerlink" title="（一）从哪里来："></a>（一）从哪里来：</h3><p>​            一个程序被运行，其代码从磁盘中到内存中，就开启了一个进程。</p>
<h4 id="程序和进程的关系可以理解为："><a href="#程序和进程的关系可以理解为：" class="headerlink" title="* 程序和进程的关系可以理解为："></a>* 程序和进程的关系可以理解为：</h4><p>​                        可以把进程当作程序的一个实例。</p>
<p>​                        ① 一个程序可以有很多个实例进程（大部分程序）</p>
<p>​                                    比如：word，记事本， 浏览器，etc.，每次开启这个程序，就会出现一个新的实例进程。</p>
<p>​                        ② 一个程序也可能只有一个实例进程</p>
<p>​                                    比如：网易云音乐，360安全卫士等，这些程序启动一个再启动一个，也不会出现第二个进程。</p>
<h3 id="（二）作用："><a href="#（二）作用：" class="headerlink" title="（二）作用："></a>（二）作用：</h3><p>​            加载指令、管理内存、管理IO。</p>
<h3 id="（三）是最小的资源分配单位。"><a href="#（三）是最小的资源分配单位。" class="headerlink" title="（三）是最小的资源分配单位。"></a>（三）是最小的资源分配单位。</h3><h3 id="（四）跟线程的关系"><a href="#（四）跟线程的关系" class="headerlink" title="（四）跟线程的关系"></a>（四）跟线程的关系</h3><p>​            进程是线程的容器。线程存在于进程内，是进程的一个子集。</p>
<h3 id="（五）特点："><a href="#（五）特点：" class="headerlink" title="（五）特点："></a>（五）特点：</h3><ol>
<li><p>​    基本上相互独立</p>
</li>
<li><p>​    拥有共享资源</p>
<p>​        如：内存空间</p>
<p>​                供进程内的线程使用。</p>
</li>
<li><p>量级：</p>
<p>​        进程量级比线程高一些，上下文切换成本较线程高。</p>
<p>​        </p>
</li>
</ol>
<h3 id="（六）进程间通信："><a href="#（六）进程间通信：" class="headerlink" title="（六）进程间通信："></a>（六）进程间通信：</h3><p>​            较为复杂。</p>
<h4 id="1-同一台机器上"><a href="#1-同一台机器上" class="headerlink" title="1. 同一台机器上"></a>1. 同一台机器上</h4><p>​                        IPC（Inter-process communication）</p>
<h4 id="2-不同机器上"><a href="#2-不同机器上" class="headerlink" title="2. 不同机器上"></a>2. 不同机器上</h4><p>​                        需要通过网络，并遵守共同协议，如：HTTP协议。</p>
<h2 id="二、对线程的理解"><a href="#二、对线程的理解" class="headerlink" title="二、对线程的理解"></a>二、对线程的理解</h2><h3 id="（一）从哪里来：-1"><a href="#（一）从哪里来：-1" class="headerlink" title="（一）从哪里来："></a>（一）从哪里来：</h3><p>​            一个进程可以分为一个到多个线程</p>
<h3 id="（二）线程本质上到底是什么"><a href="#（二）线程本质上到底是什么" class="headerlink" title="（二）线程本质上到底是什么"></a>（二）线程本质上到底是什么</h3><p>​            线程是一个指令流。</p>
<h3 id="（三）作用："><a href="#（三）作用：" class="headerlink" title="（三）作用："></a>（三）作用：</h3><p>​            一个线程，将指令流中的一条条指令，<strong><u>以一定顺序</u></strong>，交给CPU执行。</p>
<p>​            即：线程是用来执行指令的。</p>
<h3 id="（四）是最小的调度单位"><a href="#（四）是最小的调度单位" class="headerlink" title="（四）是最小的调度单位"></a>（四）是最小的调度单位</h3><h3 id="（五）跟进程的关系："><a href="#（五）跟进程的关系：" class="headerlink" title="（五）跟进程的关系："></a>（五）跟进程的关系：</h3><p>​            进程是线程的容器。线程存在于进程内，是进程的一个子集。</p>
<h3 id="（六）线程间通信："><a href="#（六）线程间通信：" class="headerlink" title="（六）线程间通信："></a>（六）线程间通信：</h3><p>​            相对简单。</p>
<p>​            共享同一个进程中的内存资源。</p>
<p>​                        如：多个线程可以访问同一个共享变量。</p>
<h3 id="（七）特点"><a href="#（七）特点" class="headerlink" title="（七）特点"></a>（七）特点</h3><ol>
<li><p>量级：</p>
<p>​        相对轻量级，上下文切换成本较低。</p>
</li>
</ol>
<h2 id="三、程序、进程、线程的关系图解"><a href="#三、程序、进程、线程的关系图解" class="headerlink" title="三、程序、进程、线程的关系图解"></a>三、程序、进程、线程的关系图解</h2><img src="/2020/07/24/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/Typora 笔记\java并发 复习\pic\程序、进程、线程.PNG" style="zoom: 33%;">

<p><code>注意</code></p>
<ol>
<li><p><code>每开启一个程序，就有了一个进程。</code></p>
<p>​    <code>有些程序可以多次开启，所以可以有多个进程，比如开启多个word</code></p>
<p>​    <code>有些程序只能开启一次，重复开启不会拥有新的进程，比如网易云音乐</code></p>
</li>
</ol>
<p>[^以上内容均为个人理解，若有问题，欢迎指正交流~~  <a href="mailto:xiaoyingblog@163.com">xiaoyingblog@163.com</a> ^_^]: </p>
<p>​        </p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>My New Post</title>
    <url>/2020/03/31/My-New-Post/</url>
    <content><![CDATA[<p>This is a test file. Hope my blog runs perfectly. ^-^</p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
